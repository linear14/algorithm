# 결과

| 메모리(KB) | 시간(ms) | 비고 |
| :--------: | :------: | :--- |
| 12964 | 360 |      |

# 과정
## 처음에 생각했던 방식
큰 n의 결과가 앞선 n의 결과를 이용할 것 같았기 때문에 dp로 접근하려고 했다. 이에 기반하여 규칙을 찾으려고 했다.

조금만 생각해보니, 정답이 들어있는 dp 배열을 이용하기 위해 아래와 같은 방식을 사용할 수 있었다.
```
1 -> 1^2 (1개)
2 -> 1^2 (1개) + dp[1] (1개)
3 -> 1^2 (1개) + dp[2] (2개)
4 -> 2^2 (1개)
5 -> 2^2 (1개) + dp[1] (1개)
6 -> 2^2 (1개) + dp[2] (2개)
...
9 -> 3^2 (1개)
10 -> 3^2 (1개) + dp[1] (1개)
...
n -> floor(sqrt(n))^2 (1개) + dp[n - floor(sqrt(n))^2] (memo된 갯수)
```
이렇게 식을 세웠고 무리없이 진행되는 듯 했으나, `틀렸습니다`가 나왔다. 예를 들어, `41`을 입력값으로 했을 때, 내가 짠 로직대로라면 `6^2 + dp[5]` 이기 때문에 3이 나온다. 하지만 실제 정답은 `4^2 + 5^2`인 2가 된다.

## 조금만 더 생각해서
자신의 sqrt 값보다 작으면서 가장 가까운 정수의 제곱수를 빼는게 무조건 좋은 선택이 아니라는 것을 알았다. 하지만 어떤 제곱수를 빼주는 것이 memoization을 사용할 수 있는 방법임을 알았기 때문에 이를 활용하려고 했다.  

그 결과, `자신의 sqrt 값보다 작은 모든 정수의 제곱수`를 순회하며 제곱수의 합을 최소로 가지는 숫자를 찾는 것이 문제 해결 방법임을 생각해 낼 수 있었다. 

최대 입력값이 100,000이고 이 수의 sqrt 처리 값은 300이 조금 넘으므로, 대략적으로 O(NlogN)의 시간 복잡도를 가진다고 판단했다.