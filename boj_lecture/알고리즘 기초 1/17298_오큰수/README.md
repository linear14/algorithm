# 결과
| 메모리(KB) | 시간(ms) | 비고 |
| :---: | :---: | :-- |
| 246880 | 1032 |  | 

# 과정
## 생각 흐름
### 가장 단순하게 생각해보자
0번째 인덱스의 원소보다 더 큰 수를 1 ~ (n-1) 인덱스까지 순회하며 찾는다.  
1번째 인덱스의 원소보다 더 큰 수를 2 ~ (n-1) 인덱스까지 순회하며 찾는다.  
...  
(n-2)번째 인덱스의 원소보다 더 큰 수를 (n-1) 인덱스에서 찾는다.  

전체 탐색 방식은 시간 복잡도 O(N^2)이기 때문에 사용하지 않기로 했다.

### DP 인가?
오른쪽 원소로 갈수록 오큰수를 찾을 때 드는 복잡도가 줄어든다. 비교할 수가 적기 때문이다. 오른쪽 원소의 오큰수를 찾고, 그 해를 왼쪽 원소의 오큰수를 도출하는데 사용할 수 있을까 생각해봤다. 하지만 아래같은 예외 상황이 있을 것 같아 이 방법도 제외했다.
```jsx
// arr = [8, 3, 4, 9]
dp[3] = -1  // -1
dp[2] = arr[3] > arr[2] ? arr[3] : dp[3] // 9
dp[1] = arr[2] > arr[1] ? arr[2] : dp[2] // 4
dp[0] = arr[1] > arr[0] ? arr[1] : dp[1] // 4 ??
```

### 현재idx보다 큰 수가 나오는 순간이 중요한 것 같다
오큰수를 결정할 수 있는 순간이 언제일까? 전체 원소를 순회하다가 이전 원소의 값보다 큰 값이 들어있는 포인트가 있을 것이다. 이를 이용하기로 했다.

숫자 배열은 감소하는 구간이 있을 것이고, 증가하는 구간이 있게된다. 감소하는 구간에서는 다음 원소가 오큰수가 아니므로 넘어가면 된다. 증가하는 구간에서의 원소가 A라면, 이전 구간에서 A보다 작은 값들의 오큰수는 모두 A가 된다. 또한, 오큰수가 결정된 수들은 더이상 체크할 필요가 없다.

아직 검증되지 않은 수들을 스택에 차곡차곡 쌓아두고, 증가하는 순간에서의 원소보다 작은 값들을 스택에서 빼주는 방식으로 구현했다.