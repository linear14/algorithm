# 결과

| 메모리(KB) | 시간(ms) | 비고 |
| :--------: | :------: | :--- |
| 9848 | 208 |      |

# 과정
DP라고 충분히 생각할 수 있는 문제였다. 구입하고자 하는 카드의 수를 기준으로 DP 배열을 만들어 관리하면 될 것 같았다.  

```
1개의 카드를 구매하는 경우의 최대 비용 DP[1]  
2개의 카드를 구매하는 경우의 최대 비용 DP[2]   
...   
n개의 카드를 구매하는 경우의 최대 비용 DP[n]
```

위와 같은 방법으로 말이다.

그렇다면 어떻게 부분해를 구할 것인지에 대해 고민이 컸다. 처음 생각했던 방법은 단순했다. DP[n]은 아래와 같은 후보군들의 최대값을 구하는 방식을 적용하면 된다고 생각했다.  
```
n-1개의 카드를 구매하는 경우의 최대 비용 + 1개의 카드 가격 => DP[n-1] + P[1]
n-2개의 카드를 구매하는 경우의 최대 비용 + 2개의 카드 가격 => DP[n-2] + P[2]
...
1개의 카드를 구매하는 경우의 최대 비용 + n-1개의 카드 가격 => DP[1] + P[n-1]
```

이 방식은 일반적인 방식이 맞는 것 같다. 다만, 모든 dp값을 구할 때 마다 n번의 연산을 수행하기 때문에 시간 복잡도가 증가하고 당연히 시간 초과를 낼거라고 생각을 해서 다른 방법이 있나 고민을 많이 했었다.  

근데 생각해보니, 1000^2 만큼의 시간을 먹더라도 문제 요구사항인 1초 만큼 절대 도달할리 없었다. O(N^2)가 허용되던 문제였던 것이다. 당연히 시간이 넘을거라는 잘 하지않는 실수를 범하면서 시간을 많이 빼앗겼던 문제였다. 반성!