# 결과

| 메모리(KB) | 시간(ms) | 비고 |
| :--------: | :------: | :--- |
| 16092 | 260 |      |

# 과정

## 아이디어 획득
숫자가 제거되지 않을 경우의 연속합을 구하는 과정은 dp를 통해 간단히 구현할 수 있다. `Math.max(arr[i], dp[i-1] + arr[i])` 이 방식으로 구하면 되니깐..  
그런데, 특정 숫자가 제거 된 경우 연속합을 어떻게 구해야할지 도무지 떠오르지가 않았다.  
특정 수가 제거되었다고 가정한 상태의 dp 배열을 또 만든다면 10만 x 10만 형태의 2차원 배열이 되기 때문에 시간 / 메모리 오류가 무조건 발생한다.  

고민 끝에.. 약간의 힌트를 (참고 자료)의 블로그에서 찾아봤다.  

글을 살짝 내리다가 `오른쪽 방향의 연속합과 왼쪽 방향의 연속합을 구한다`는 말을 딱 보자마자 우와... 이렇게 접근할수도 있구나 생각했다.  
dp를 양쪽에서 계산한다는 아이디어를 보자마자 해결책이 떠올랐고 그대로 구현했다.  

```
배열에서 특정 원소가 빠진 경우에 대한 고려를 할 때, 양쪽에서 접근하는 dp를 생각해보자
```

## 그래서 해결책이 뭐지?

해당 문제에서 dp의 i번째 원소가 의미하는 것은, arr[i] 번째 원소가 선택되었을 경우에 i번째 원소까지의 최대 연속합이다.  
즉, 왼쪽에서 시작한 dp의 경우에서의 dp[i]와 오른쪽에서 시작한 dp의 경우에서의 dp[i+2]의 합이 의미하는 것은? => `i+1번째 원소가 빠진 경우에서의 연속합의 일부`가 되는 것이다.  
i+1번째 원소가 빠진 경우에서의 최대 연속합 후보는 `Math.max(왼쪽부터 시작한 dp[i], 왼쪽부터 시작한 dp[i] + 오른쪽부터 시작한 dp[i+2])`가 된다. 문제를 풀 때는 왼쪽부터 시작한 dp의 경우에서의 최대값을 구해놨기 때문에 합해진 경우에 대해서 추가적으로 max 값을 구해주면 된다. (자세한건 코드를 보는걸루!)


# 참고 자료

- https://steady-coding.tistory.com/181