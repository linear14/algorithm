# 결과

| 메모리(KB) | 시간(ms) | 비고 |
| :--------: | :------: | :--- |
| 10128 | 220 |      |

# 과정
## 아이디어
오랜만에 골드3 문제를 풀어서 매우 쫄았는데.. ㅎㅎ 여태 배웠던 방식을 이용해 어떻게 접근하면 좋을지 고민을 해보니 금방 방법이 떠올랐다.  
dp배열에 두가지 상황에 대한 memoization을 진행했는데, 각 인덱스에 대해 첫 저장값은 `값이 올라가는 상황에서 자신이 선택됐을 경우` (LIS와 동일한 경우)이고, 두번째 저장값은 `값이 내려가는 상황에서 자신이 선택됐을 경우`이다.

값이 올라가는 상황은 LIS를 구하는 것 처럼 진행했고, 값이 내려가는 상황은 현재 값이 비교 값보다 작을 경우, 비교 값의 인덱스(j)에 해당하는 dp[j][0]과 dp[j][1] 중 더 큰 값을 택하는 것으로 memoization을 진행했다. 왜냐하면 계속 올라가다가 꺽인 이후 첫 값(0번째 인덱스)일수도 있고, 아니면 내려가는 도중의 값(1번째 인덱스)일수도 있기 때문이다. 
