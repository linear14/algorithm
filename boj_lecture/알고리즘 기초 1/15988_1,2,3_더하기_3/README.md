# 결과

| 메모리(KB) | 시간(ms) | 비고 |
| :--------: | :------: | :--- |
| 131532 | 724 |      |
| 45056 | 276 |      |

# 과정
## 메모리 최적화?
처음에 2차원 배열을 이용해 문제에 접근했다. 마지막으로 더해지는 수를 1, 2, 3으로 구분한 뒤 `dp[i][1] ~ dp[i][3]`에 각각 담았다.  
최종적인 정답 역시 해당 3개의 원소값을 모두 더해 계산했다.

이렇게 제출하니 메모리가 엄청나게 많이 필요함을 알 수 있었다. 추가적으로, `dp[i][j]`를 구하기 위해 `dp[i-k]`의 1 ~ 3 번째 원소의 합을 구하는 과정이 추가 연산되므로 시간도 더 많이 들었다.

2차원 배열로 만들지 않고, 1차원 배열로 풀어도 충분했다. 숫자 i를 만들기 위한 방법의 수를 담는 dp 배열로 말이다.  
배열의 크기가 1/3만큼 줄어드니 사용되는 메모리 공간 역시 1/3으로 줄었고, 각 배열 원소값을 계산하는 과정 역시 1/3로 줄어드니 시간도 그정도 줄어든 것 같다.