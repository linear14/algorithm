# 결과
| 메모리(KB) | 시간(ms) | 비고 |
| :---: | :---: | :-- |
| 134256 | 1032 | | 

# 과정
## 아이디어
### 흐름
문자열을 배열로 바꾼 뒤 커서의 위치에 따라 새로운 값을 추가하고 삭제하는 연산은 O(N) 만큼의 비용을 가지게 된다.  
시간 제한이 여유롭지 못한 문제이기 때문에, 시간 복잡도를 줄여야한다.

커서의 위치를 기준으로 좌우에 해당하는 문자들을 별도의 stack으로 관리하면 될 것 같았다. (이전에 풀어봐서 기억에 남았던 것 같다)
`L`명령은 왼쪽 스택에서의 pop() 반환 값을 오른쪽 스택에 push() 하면 된다.  
반대로, `D`명령은 오른쪽 스택에서의 pop() 반환 값을 왼쪽 스택에 넣어주면 된다.  
`B`명령은 왼쪽 스택을 단순 pop() 처리, `P`명령은 따라오는 값을 왼쪽 스택에 push() 하면 된다.

## 회고?
동일한 자료구조를 2개 사용하는 아이디어가 이곳저곳 많이 사용되는 것 같다. 풀이 방법으로 잘 기억해둬야겠다.