# 결과
| 메모리(KB) | 시간(ms) | 비고 |
| :---: | :---: | :-- |
| 31364 | 316 | | 

# 과정
## 아이디어
### 흐름
스택에 숫자를 넣을때는 1부터 n까지 차례대로 넣어야하는 규칙이 있다.  
따라서, 다음에 넣을 숫자를 나타내는 변수 `next`를 선언해 사용했다.

1. 다음 target 숫자에 도달할 때 까지 stack에 `push(next)`를 수행한다.
    - next는 stack에 들어갈 때 마다 값이 1만큼 증가한다.
    - 만약, next가 처음부터 target보다 크다면 이미 스택에 해당 숫자가 들어가있는 것이므로 push를 수행하지 않는다.
2. 도달했다면, stack에서 `pop()`을 수행한다. 빠진 숫자가 현재 target과 같다면 정상적으로 처리된 것이지만, 만약 다르다면 문제가 발생한 것이므로 `NO`를 반환하고 알고리즘 수행을 종료한다.

### 예외가 있는지?
- stack에서 pop() 처리시 stack이 비어있는 경우에 대한 처리를 안했는데, 현 알고리즘에서는 pop() 수행 시 무조건 stack에 1개 이상의 원소가 있는 구조이기 때문에 건들 필요가 없었다.