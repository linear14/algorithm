# 결과

| 메모리(KB) | 시간(ms) | 비고 |
| :--------: | :------: | :--- |
| 11176 | 388 |      |

# 과정

## 왜 틀렸을까?

처음에는 인접한 두 칸이 같은 색의 사탕이 들어있어도 교환하고 최대값을 계산하도록 했다. 하지만, 문제에서 괜히 이런 경우에는 교환하지 않는다고 제시한게 아니었다..
```
CCC
AAA
ACB
```
위와 같은 예에서, 인접한 사탕이 같이 색이어도 교환한다면 3이 나오지만, 문제 조건에 따라 인접한 사탕 색이 같은 경우에는 교환하지 않을 경우에서는 정답이 2가 된다. 따라서 이를 고려해서 추가 분기문을 작성했다.

## 왜 또 틀렸을까..

교환 시 영향이 가는 column과 row에 대해서만 최대값을 구하는 로직을 짰다. 하지만, 아래와 같은 예외 상황에서는 영향 받지 않는 영역에서까지를 고려해야했다.
```
CCC
AAB
AAC
```
만약 여기서 2번째 줄의 A와 B를 변경한다면, 맨 위의 CCC는 계산하지 않는 로직(2열, 3열, 2행만 고려했었음..)이었다. 따라서 절대 3이라는 출력이 나올 수 없는 구조였다. 결국, 한 번의 교환이 있을 시 모든 행과 열에서의 최대값을 구하는 과정을 거쳐야했다. 초기에 이 방식은 매우 비효율적일 것 같아서 제외했던 방법인데,, 결국 돌고 돌아 다시 원래대로 오게 되었다. 
