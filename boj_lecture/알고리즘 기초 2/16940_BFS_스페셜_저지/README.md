# 결과

| 메모리(KB) | 시간(ms) | 비고 |
| :--------: | :------: | :--- |
| 81524 | 6188 |      |
| 86516 | 744 | |

# 과정

## 생각 과정

방문 순서가 들어있는 배열의 원소를 하나씩 순회하면서, 해당 원소와 이웃한 node들을 모두 가져올 수 있었다. (이를 nexts 배열에 저장했다.) 이 때, 이미 방문한 node들은 재차 방문할 필요가 없으므로 filter 고차함수를 이용해 이웃하면서도 방문하지 않은 노드들만 nexts로 받았다. 

이렇게 되면, nexts 배열의 원소들이 큐에 들어가게 되는것이다. 다음 원소들이 들어갈 시작 위치를 포인터 변수(adjStartIdx)로 계속 추적하면서, orders 배열의 `adjStartIdx`부터 `adjStartIdx + nexts.length` 만큼의 원소들이 nexts배열의 원소를 잘 포함하고 있는지 계속 확인하는 방식으로 일치 여부를 판단했다.

## 시간 복잡도 개선

최초 문제 풀이시 6188ms의 시간이 나왔다. 이 문제의 경우 다른 분들도 4000 ~ 7000ms까지 나오는 경우가 있다보니.. 완전 틀린 방법으로 접근했던건 아니라고 생각들어서 안심이었다. 하지만, 500ms 단위까지 시간을 줄이신 분들도 분명 계셨기 때문에 찝찝했다. 덕분에 내가 생각했을 때 내 코드에서 시간을 많이 잡아먹는 부분이 어딜까 고민을 해볼 수 있었다.

어떤 값이 여러 값들중의 하나에 속하는지 확인하기 위해 배열을 사용했었는데, 이를 Set 자료 구조로 변경해서 구현했다. 또한, 마지막에 방문하지 않은 노드가 있는지 확인하기 위해 isVisited 배열 중 방문하지 않은 곳을 filter 메서드를 이용해 직접 새로운 배열로 만들었던걸 방문할 때 마다 visitCount를 높이는 방식으로 시간을 줄일 수 있었다.

간단하고 당연한거지만.. 이런 것들을 자꾸 빼먹고 구현하니깐! 습관적으로 할 수 있도록 연습 많이 해야겠다.