# 결과

| 메모리(KB) | 시간(ms) | 비고 |
| :--------: | :------: | :--- |
| 12768 | 452 | 시간초과 hell |

# 과정

## 시간초과..

시간초과 때문에 고생 많이했던 문제였다. BFS 재귀를 통해 문제를 풀었는데, 시간 초과를 고려한 해결 아이디어를 가지고 있어야겠다고 생각했다.

### 인접행렬 / 인접리스트
문제 해결의 키워드는 인접리스트였다. 처음에는 단순 데이터 접근이 편할 것 같은 이유로 인접 행렬을 선택해 문제를 풀었다.  
이럴경우에 idx 접근으로 편하게 다음 선택 node를 선택할 수 있다는 장점이 있었다. 하지만, 치명적인 단점이 있었는데, 다음 노드를 선택하는 과정에서 0번 인덱스부터 n-1번 인덱스까지 모두 탐색을 해야한다는 것이었다. 해당 문제에서는 n이 2000정도였는데, bfs를 최대 4번 돌아서 2000^4 만큼까지 시간이 걸릴 가능성이 있었다. 즉, 효율적이지 못한 방식이다.

인접 리스트를 이용하면, 다음 노드의 후보 개수만큼만 체크하기 때문에 훨씬 효율적이었다. 물론, 후보 개수가 2000개에 근접한다면 문제가 될 수 있었겠지만, 이를 위배하는 복잡한 경우를 문제의 테스트케이스에서 제공하지 않았기 때문에 해결할 수 있었다. 