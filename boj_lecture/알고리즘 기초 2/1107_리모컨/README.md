# 결과

| 메모리(KB) | 시간(ms) | 비고 |
| :--------: | :------: | :--- |
| 9722 | 164 |      |

# 과정

## 뭔가 꽤 괜찮게 푼 거 같다!

다른 분들이 푼거에 비해 메모리도 적게 사용하고 시간도 적게 사용했다. 그렇다고 코드 길이가 긴 것도 아니다. (오히려 중복 부분이 있는거 함수화 시켜야했는데, 나중에 정리해야지 하고 있다가 깜빡하고 그냥 제출해서 일단 넘겼다.)

## 아이디어

### 어떻게 풀까?

어떻게 풀어야할까 고민을 많이 했다. 떠올랐던 아이디어는, 타겟으로 정해진 숫자로부터 가장 가깝게 만들 수 있는 숫자가 어떤게 있는지 찾는 것이었다. 찾은 숫자에서 +를 누르거나 -를 눌러 타켓 숫자를 만들 수 있기 때문이다. 이 때, `타켓 숫자보다 큰 숫자중 가장 가까운 수`(up)와 `작은 숫자중 가장 가까운 수`(down)를 찾기로 했다. 찾은 뒤에는 아래의 값들 중에서 최소값이 정답이 된다.

1. up.length + (up - target)
2. down.length + (target - down)
3. |target - 100|

### 효율적인 방법을 찾자

up혹은 down을 구하기 위한 방법이 어떤게 있을까? target에서 1씩 더하거나 빼가며, 만들어진 숫자가 부서진 숫자버튼의 수를 포함하지 않는 경우를 찾으면 된다. 하지만, 1씩 값을 변경해가며 찾는것은 비효율적이라는 생각이 들었다. 따라서, 아래와 같은 방법을 사용하기로 했다. up을 찾는 경우를 예로 들어 기록하겠다.

target `76543`이 있다고 가정한다. 부서진 숫자는 [0, 1, 5, 7, 9] 이라고 가정한다. 나는 target보다 더 큰 수중에서 부서진 숫자들을 이용하지 않은 가장 가까운 수를 찾아야 한다.

1. 맨 앞자리 숫자인 7이 부서진 숫자에 포함되는지 확인한다.
2. 포함되므로, 두번째 자리 숫자부터 끝까지는 어떤 수가 오더라도 만들 수 없는 숫자가된다.
3. 따라서, 맨 앞자리는 적어도 8이상의 수가 들어간다.
  1. 이를 위해 숫자를 `79999`로 만들어준다.
  2. 그리고 +1을 더해주어 `80000`을 만든다. (이렇게 해야 자리수 넘어갈 때 계산이 편해짐)
4. 맨 앞자리 숫자인 8이 부서진 숫자에 포함되는지 확인한다.
5. 포함되지 않으므로, 두 번째 숫자인 0이 부서진 숫자에 포함되는지 확인한다.
6. 포함되므로, 세번째 자리 숫자부터 끝까지는 어떤 수가 오더라도 만들 수 없는 숫자가 된다.
7. 따라서, 두번째 자리는 적어도 1이상의 수가 들어간다.
  1. 이를 위해 숫자를 `80999`로 만들어준다.
  2. 그리고 +1을 더해주어 `81000`을 만든다.
8. 두번째 자리 숫자인 1이 부서진 숫자에 포함되는지 확인한다.
9. 포함되므로, 세번째 자리 숫자부터 끝까지는 어떤 수가 오더라도 만들 수 없는 숫자가 된다.
10. 따라서, 두번째 자리는 적어도 2이상의 수가 들어간다.
  1. 이를 위해 숫자를 `81999`로 만들어준다.
  2. 그리고 +1을 더해주어 `82000`을 만든다.
11. 두번째 자리 숫자인 2가 부서진 숫자에 포함되는지 확인한다.
12. 포함되지 않으므로, 세 번째 숫자인 0이 부서진 숫자에 포함되는지 확인한다.
...
최종적으로 `82222`가 나오게 된다.

이런식으로 target에서 1씩 더하거나 빼서 계산한게 아니라, 큰 자리수의 숫자부터 부서진 숫자에 포함되는지 확인하면서 한 번에 많은 값을 더하거나 빼주었다.
